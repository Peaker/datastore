* Later: Use ContainerDBRef:

-- Allows indexing by any Hashable type, guarantees correct type
-- lookup/setting, but cannot guarantee lookup success

import Data.Hash(Hashable, hash, Hash(asWord64))
import Data.Binary.Put(runPut)

instance Hashable ByteString where
  hash = hash . unpack

hashToBS :: Hash -> SBS.ByteString
hashToBS = runPut . putByteString . asWord64

hashBS :: Hashable a => a -> SBS.ByteString
hashBS = hashToBS . hash

------------------------------------------------

data ContainerDBRef a = ContainerDBRef {
  containerBaseGuid :: Guid
  }

instance Binary (ContainerDBRef a) where
  get = fmap ContainerDBRef (getByteString guidLen)
  put = putByteString . containerBaseGuid

newContainer :: IO (ContainerDBRef a)
newContainer = ContainerDBRef `fmap` randomBS guidLen

lookupContainerAt :: (Binary a, Hashable b) => ObjectStore -> ContainerDBRef a -> b -> IO (Maybe a)
lookupContainerAt os (ContainerDBRef key) component =
  (fmap . fmap) decodeS . Db.lookup os . hashBS $ (key, component)

setContainerAt :: (Binary a, Hashable b) => ObjectStore -> ContainerDBRef a -> b -> a -> IO ()
setContainerAt os (ContainerDBRef key) component x =
  Db.set os (hashBS (key, component)) . encodeS $ x

* Version should also be an IRef wrapper around VersionData, like View
  and Branch?

* Anchors to return IRef and not Ref?

* Editor currently needs a transaction for append child:

  * For Transactions, I somehow need to be able to re-use a Ref for
    "d" as a Ref for "Transaction d"

    * Maybe need something like: FRef a b = FRef (IRef a) (a <-> b),
      that can be used with any store, instead of Store.Ref?

* Have a reflog too
  * Implicit name for all Undo edges (carry around the "current undo
    rev" which moves with the current rev to make sure there's just
    one tag per undo sequence)

* Add fromIRefDefault that replaces fromJust with fromMaybe -- remove
  lots of code from makeDb and just add defaults to Anchors

* Crash resilience:
  * Currently I might update a branch ptr, and crash before the view
    was updated:
    * Wrap view movements/etc with lower-layer transactions
    * Use Berkeley transactions to implement storeChanges

* Immutable key/value store (add only) interface?

  * Can be pure if guaranteed exclusiveness

    * IRef contains a safe hash

    * addNew :: Value -> IRef Value

      * Doesn't allow circular data-structures, do I need them?

    * read :: IRef Value -> Value

    * Revision uses pure interface for main store but mutable store
      for the View cache and branches

* Collapsing, max-depth under which you jump to a new root

----------------------------------------

* Interpret Tree as Code!
  * Scheme / Untyped Haskell
  * Run as you edit
  * Finally editing some code.. UI enhancements...

* Add typing:
  * Full type inference
  * Back-refs from all uses: When "x" changes its type, re-test all
    uses of "x" for validity, if invalid, insert tchorim

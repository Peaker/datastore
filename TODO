* Db.Ref -> Data.IRef
  New Db.Ref that has: property :: Db -> IRef a -> Property a

* Try to get rid of Accessor and see if it works out. In any case,
  Accessor would have to hold IRefProperty and not Db. Note I end up
  passing Db anyway, so not sure Accessor helps at all.

* Pass IRefProperty around manually for now, because using IRefT
  is problematic...

  * Monad transformers are incompatible with all Haskell libraries
    that take IO actions, and it's unclear how to fix it, especially
    when involving any FFI that takes callbacks...  Need to rewrite
    various functions (withFile/etc) and wrap FFI-callback-code with
    forkIO's that message the transformer stack thread

* Folding, max-depth under which you jump to a new root

* Maybe need 'overwrite selection' in TextEdit so that I can have the
  "<new node>" be overwritten when you go on it?

  * Can I somehow show "<empty>" for empty text edits in a way that
    considers it a single char that's overwritten by any operation?

* Interpret Tree as Code!
  * Scheme / Untyped Haskell
  * Run as you edit
  * Finally editing some code.. UI enhancements...

* Add typing:
  * Full type inference
  * Back-refs from all uses: When "x" changes its type, re-test all
    uses of "x" for validity, if invalid, insert tchorim

* Organize src?

* Revision control:

  * type ObjectValue = ByteString

  * data Change = Change {
      oldValue :: ObjectValue,
      newValue :: ObjectValue
      }

  * Version object:

    versionDepth :: Int
    versionParent :: DBRef Version
    versionChanges :: [(ObjectKey, Change)]

  * data View = View {
      viewVersion :: DBRef Version,
      viewGUID :: GUID
      }

    * A mapping (View, ObjectKey) -> ObjectValue
      * combine :: GUID -> GUID -> GUID
      * 

* Folding, max-depth under which you jump to a new root

* Maybe need 'overwrite selection' in TextEdit so that I can have the
  "<new node>" be overwritten when you go on it?

  * Can I somehow show "<empty>" for empty text edits in a way that
    considers it a single char that's overwritten by any operation?

* Interpret Tree as Code!
  * Scheme / Untyped Haskell
  * Run as you edit
  * Finally editing some code.. UI enhancements...

* Add typing:
  * Full type inference
  * Back-refs from all uses: When "x" changes its type, re-test all
    uses of "x" for validity, if invalid, insert tchorim
